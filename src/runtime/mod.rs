//! Run compiled bytecode.

use crate::{bytecode::*, BinaryOperator, Type, UnaryOperator, Value};
use std::collections::HashMap;
use thiserror::Error;

/// A Rust function that the script can call.
pub type HostFunction = Box<dyn FnMut(&[Value]) -> Result<Value, RuntimeError>>;

/// Interprets bytecode.
pub struct VirtualMachine<'a> {
    program: &'a ProgramBytecode,
    host_functions: HashMap<String, HostFunction>,
    instruction_budget: Option<u32>,
    max_stack_depth: Option<u8>,
    stack: Vec<Value>,
}

/// An error generated by executing bytecode at runtime.
#[derive(Debug, Error)]
pub enum RuntimeError {
    #[error("type mismatch ({expected} expected {actual} actual)")]
    TypeMismatch { expected: Type, actual: Type },
    #[error("undefined function ({name})")]
    UndefinedFunction { name: String },
    #[error("undefined variable (index {index})")]
    UndefinedVariable { index: u8 },
    #[error("invalid operand ({actual})")]
    InvalidOperand { actual: Type },
    #[error("invalid argument(s)")]
    InvalidArgument,
    #[error("integer division by zero")]
    IntegerDivisionByZero,
    #[error("integer overflow")]
    IntegerOverflow,
    /// This indicates a bug in Ratón.
    #[error("stack underflow (bug in Ratón)")]
    StackUnderflow,
    #[error("stack overflow")]
    StackOverflow,
    #[error("instruction budget exceeded")]
    InstructionBudgetExceeded,
    #[error("illegal instruction")]
    IllegalInstruction,
    #[error("bytecode ended abruptly")]
    BytecodeEndedAbruptly,
}

impl<'a> VirtualMachine<'a> {
    pub fn new(program: &'a ProgramBytecode) -> Self {
        Self {
            program,
            host_functions: HashMap::new(),
            instruction_budget: None,
            max_stack_depth: None,
            stack: Vec::new(),
        }
    }

    pub fn with_instruction_budget(mut self, budget: u32) -> Self {
        self.instruction_budget = Some(budget);
        self
    }

    /// How many nested functions can be called at once. A host function is
    /// tracked as a single function.
    pub fn with_max_stack_depth(mut self, max: u8) -> Self {
        self.max_stack_depth = Some(max);
        self
    }

    /// Registers a function for all types, except unit, to cast a value to that type.
    pub fn with_type_casting(#[allow(unused_mut)] mut self) -> Self {
        #[cfg(feature = "bool_type")]
        {
            self = self.with_host_function(
                "bool",
                Box::new(|args| {
                    if args.len() != 1 {
                        return Err(RuntimeError::InvalidArgument);
                    }
                    match &args[0] {
                        Value::Bool(b) => Ok(Value::Bool(*b)),
                        #[cfg(feature = "i32_type")]
                        Value::I32(i) => Ok(Value::Bool(*i != 0)),
                        #[cfg(feature = "f32_type")]
                        Value::F32(f) => Ok(Value::Bool(*f != 0.0)),
                        #[cfg(feature = "string_type")]
                        Value::String(s) => Ok(Value::Bool(!s.is_empty())),
                        Value::Null => Ok(Value::Bool(false)),
                    }
                }),
            );
        }
        #[cfg(feature = "i32_type")]
        {
            self = self.with_host_function(
                "i32",
                Box::new(|args| {
                    if args.len() != 1 {
                        return Err(RuntimeError::InvalidArgument);
                    }
                    match &args[0] {
                        Value::I32(i) => Ok(Value::I32(*i)),
                        #[cfg(feature = "bool_type")]
                        Value::Bool(b) => Ok(Value::I32(if *b { 1 } else { 0 })),
                        #[cfg(feature = "f32_type")]
                        Value::F32(f) => Ok(Value::I32(*f as i32)),
                        #[cfg(feature = "string_type")]
                        Value::String(s) => {
                            Ok(s.parse::<i32>().map(Value::I32).unwrap_or(Value::Null))
                        }
                        _ => Err(RuntimeError::InvalidArgument),
                    }
                }),
            );
        }
        #[cfg(feature = "f32_type")]
        {
            self = self.with_host_function(
                "f32",
                Box::new(|args| {
                    if args.len() != 1 {
                        return Err(RuntimeError::InvalidArgument);
                    }
                    match &args[0] {
                        Value::F32(f) => Ok(Value::F32(*f)),
                        #[cfg(feature = "i32_type")]
                        Value::I32(i) => Ok(Value::F32(*i as f32)),
                        #[cfg(feature = "bool_type")]
                        Value::Bool(b) => Ok(Value::F32(if *b { 1.0 } else { 0.0 })),
                        #[cfg(feature = "string_type")]
                        Value::String(s) => {
                            Ok(s.parse::<f32>().map(Value::F32).unwrap_or(Value::Null))
                        }
                        _ => Err(RuntimeError::InvalidArgument),
                    }
                }),
            );
        }

        #[cfg(feature = "string_type")]
        {
            self = self.with_host_function(
                "string",
                Box::new(|args| {
                    if args.len() != 1 {
                        return Err(RuntimeError::InvalidArgument);
                    }
                    Ok(Value::String(args[0].to_string()))
                }),
            );
        }

        self
    }

    pub fn with_host_function(mut self, name: &str, func: HostFunction) -> Self {
        self.host_functions.insert(name.to_string(), func);
        self
    }

    pub fn execute(&mut self, func_name: &str, args: &[Value]) -> Result<Value, RuntimeError> {
        let func = self
            .program
            .public_functions
            .get(func_name)
            .ok_or_else(|| RuntimeError::UndefinedFunction {
                name: func_name.to_owned(),
            })?;
        if args.len() != func.arguments as usize {
            return Err(RuntimeError::InvalidArgument);
        }

        struct CallFrame {
            first_variable: u32,
            return_address: u32,
        }
        let mut call_stack = Vec::<CallFrame>::new();
        self.stack.clear();
        self.stack.extend_from_slice(args);

        let mut pc = func.ip;
        let mut instruction_budget = self.instruction_budget;

        while let Some(instruction) = self.program.instructions.get(pc as usize) {
            if let Some(instruction_budget) = &mut instruction_budget {
                if let Some(next) = instruction_budget.checked_sub(1) {
                    *instruction_budget = next;
                } else {
                    return Err(RuntimeError::InstructionBudgetExceeded);
                }
            }
            match instruction {
                Instruction::AllocVariables(n) => {
                    let relative_exlusive_index =
                        call_stack.last_mut().map(|f| f.first_variable).unwrap_or(0) as usize
                            + *n as usize;
                    if let Some(n) = relative_exlusive_index.checked_sub(self.stack.len()) {
                        self.stack.extend((0..n).map(|_| Value::Null));
                    }
                    pc += 1;
                }
                Instruction::LoadConstant(val) => {
                    self.stack.push(val.clone());
                    pc += 1;
                }
                &Instruction::LoadVariable(index) => {
                    let relative_index =
                        call_stack.last_mut().map(|f| f.first_variable).unwrap_or(0) as usize
                            + index as usize;
                    let val = self
                        .stack
                        .get(relative_index)
                        .ok_or_else(|| RuntimeError::UndefinedVariable { index })?;
                    self.stack.push(val.clone());
                    pc += 1;
                }
                &Instruction::StoreVariable(index) => {
                    let val = self.stack.pop().ok_or(RuntimeError::StackUnderflow)?;
                    let relative_index =
                        call_stack.last_mut().map(|f| f.first_variable).unwrap_or(0) as usize
                            + index as usize;
                    *self
                        .stack
                        .get_mut(relative_index)
                        .ok_or_else(|| RuntimeError::UndefinedVariable { index })? = val;
                    pc += 1;
                }
                Instruction::UnaryOperator(op) => {
                    let operand = self.stack.pop().ok_or(RuntimeError::StackUnderflow)?;
                    let _result = match op {
                        #[cfg(feature = "bool_type")]
                        UnaryOperator::Not => {
                            let b = operand.as_bool()?;
                            Value::Bool(!b)
                        }
                        UnaryOperator::Negate => match operand {
                            #[cfg(feature = "i32_type")]
                            Value::I32(i) => {
                                Value::I32(i.checked_neg().ok_or(RuntimeError::IntegerOverflow)?)
                            }
                            #[cfg(feature = "f32_type")]
                            Value::F32(f) => Value::F32(-f),
                            _ => {
                                return Err(RuntimeError::InvalidOperand {
                                    actual: operand.type_of(),
                                });
                            }
                        },
                    };
                    #[allow(unreachable_code)]
                    self.stack.push(_result);
                    pc += 1;
                }
                Instruction::BinaryOperator(op) => {
                    let right = self.stack.pop().ok_or(RuntimeError::StackUnderflow)?;
                    let left = self.stack.pop().ok_or(RuntimeError::StackUnderflow)?;
                    let _result = match op {
                        BinaryOperator::Add => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => {
                                Value::I32(l.checked_add(r).ok_or(RuntimeError::IntegerOverflow)?)
                            }
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::F32(l + r),
                            #[cfg(feature = "string_type")]
                            (Value::String(l), Value::String(r)) => {
                                Value::String(format!("{l}{r}"))
                            }
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        BinaryOperator::Subtract => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => {
                                Value::I32(l.checked_sub(r).ok_or(RuntimeError::IntegerOverflow)?)
                            }
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::F32(l - r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        BinaryOperator::Multiply => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => {
                                Value::I32(l.checked_mul(r).ok_or(RuntimeError::IntegerOverflow)?)
                            }
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::F32(l * r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        BinaryOperator::Divide => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => {
                                if r == 0 {
                                    return Err(RuntimeError::IntegerDivisionByZero);
                                }
                                Value::I32(l.checked_div(r).ok_or(RuntimeError::IntegerOverflow)?)
                            }
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::F32(l / r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        BinaryOperator::Modulo => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => {
                                if r == 0 {
                                    return Err(RuntimeError::IntegerDivisionByZero);
                                }
                                Value::I32(l % r)
                            }
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::F32(l % r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::Equal => Value::Bool(left == right),
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::NotEqual => Value::Bool(left != right),
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::LessThan => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => Value::Bool(l < r),
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::Bool(l < r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::LessThanOrEqual => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => Value::Bool(l <= r),
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::Bool(l <= r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::GreaterThan => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => Value::Bool(l > r),
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::Bool(l > r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::GreaterThanOrEqual => match (&left, &right) {
                            #[cfg(feature = "i32_type")]
                            (&Value::I32(l), &Value::I32(r)) => Value::Bool(l >= r),
                            #[cfg(feature = "f32_type")]
                            (&Value::F32(l), &Value::F32(r)) => Value::Bool(l >= r),
                            _ => {
                                return Err(RuntimeError::TypeMismatch {
                                    expected: left.type_of(),
                                    actual: right.type_of(),
                                });
                            }
                        },
                        #[cfg(feature = "bool_type")]
                        BinaryOperator::And | BinaryOperator::Or => {
                            return Err(RuntimeError::IllegalInstruction);
                        }
                    };
                    #[allow(unreachable_code)]
                    self.stack.push(_result);
                    pc += 1;
                }
                Instruction::Jump(target) => {
                    pc = *target;
                }
                #[cfg(feature = "bool_type")]
                Instruction::JumpIfFalse(target) => {
                    let cond = self.stack.last().ok_or(RuntimeError::StackUnderflow)?;
                    let cond_val = cond.as_bool()?;
                    if !cond_val {
                        pc = *target;
                    } else {
                        pc += 1;
                    }
                }
                Instruction::CallByName(name, arg_count) => {
                    if self.max_stack_depth == Some(call_stack.len() as u8) {
                        return Err(RuntimeError::StackOverflow);
                    }

                    let mut call_args = Vec::new();
                    for _ in 0..*arg_count {
                        call_args.push(self.stack.pop().ok_or(RuntimeError::StackUnderflow)?);
                    }
                    call_args.reverse();

                    let result = if let Some(host_fn) = self.host_functions.get_mut(name) {
                        host_fn(&call_args)?
                    } else {
                        return Err(RuntimeError::UndefinedFunction {
                            name: name.to_string(),
                        });
                    };

                    self.stack.push(result);
                    pc += 1;
                }
                Instruction::CallByAddress(ip, arg_count) => {
                    if self.max_stack_depth == Some(call_stack.len() as u8) {
                        return Err(RuntimeError::StackOverflow);
                    }

                    let first_variable =
                        if let Some(fv) = self.stack.len().checked_sub(*arg_count as usize) {
                            fv
                        } else {
                            return Err(RuntimeError::StackUnderflow);
                        };

                    call_stack.push(CallFrame {
                        first_variable: first_variable as u32,
                        return_address: pc + 1,
                    });

                    self.stack[first_variable..first_variable + *arg_count as usize].reverse();

                    pc = *ip;
                }
                Instruction::Return => {
                    if let Some(CallFrame {
                        return_address,
                        first_variable,
                    }) = call_stack.pop()
                    {
                        if (first_variable as usize) < self.stack.len() {
                            self.stack.swap_remove(first_variable as usize);
                            self.stack.truncate(first_variable as usize + 1);
                        }
                        pc = return_address;
                    } else {
                        return self.stack.pop().ok_or(RuntimeError::StackUnderflow);
                    }
                }
                Instruction::Pop => {
                    self.stack.pop().ok_or(RuntimeError::StackUnderflow)?;
                    pc += 1;
                }
            }
        }
        Err(RuntimeError::BytecodeEndedAbruptly)
    }
}
