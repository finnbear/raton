use std::collections::{BTreeMap, HashMap, btree_map::Entry};
use thiserror::Error;

use crate::{FunctionBytecode, bytecode::Instruction};

#[derive(Clone, Debug)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "bitcode", derive(bitcode::Encode, bitcode::Decode))]
#[allow(unused)]
pub struct ProgramBytecode {
    functions: HashMap<String, u32>,
    instructions: Vec<Instruction>,
}

pub struct Linker {
    functions: BTreeMap<String, FunctionBytecode>,
}

/// An error generated by linking bytecode.
#[derive(Debug, Error)]
pub enum LinkerError {
    #[error("duplicate function ({0})")]
    DuplicateFunction(String),
}

impl Linker {
    pub fn new() -> Self {
        Self {
            functions: Default::default(),
        }
    }

    pub fn add_function(
        &mut self,
        name: String,
        bytecode: FunctionBytecode,
    ) -> Result<(), LinkerError> {
        let entry = self.functions.entry(name);
        match entry {
            Entry::Occupied(occupied) => {
                Err(LinkerError::DuplicateFunction(occupied.key().clone()))
            }
            Entry::Vacant(vacant) => {
                vacant.insert(bytecode);
                Ok(())
            }
        }
    }

    pub fn link(&self) -> ProgramBytecode {
        let mut instructions = Vec::new();
        let mut functions = HashMap::new();

        for (name, function) in &self.functions {
            functions.insert(name.clone(), instructions.len() as u32);
            instructions.extend(function.instructions.iter().map(|instruction| {
                let instruction = instruction.clone();
                if let Instruction::Call(_call, _args) = &instruction {}
                instruction
            }));
        }

        ProgramBytecode {
            functions,
            instructions,
        }
    }
}
