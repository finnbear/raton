use crate::bytecode::{FunctionBytecode, Instruction, ProgramBytecode};
use std::collections::{BTreeMap, HashMap, btree_map::Entry};
use thiserror::Error;

/// Links multiple items into a single instruction stream.
pub struct Linker {
    functions: BTreeMap<String, FunctionBytecode>,
}

/// An error generated by linking bytecode.
#[derive(Debug, Error)]
pub enum LinkerError {
    #[error("duplicate function ({0})")]
    DuplicateFunction(String),
}

impl Linker {
    pub fn new() -> Self {
        Self {
            functions: Default::default(),
        }
    }

    pub fn add_function(
        &mut self,
        name: String,
        bytecode: FunctionBytecode,
    ) -> Result<(), LinkerError> {
        let entry = self.functions.entry(name);
        match entry {
            Entry::Occupied(occupied) => {
                Err(LinkerError::DuplicateFunction(occupied.key().clone()))
            }
            Entry::Vacant(vacant) => {
                vacant.insert(bytecode);
                Ok(())
            }
        }
    }

    pub fn link(&self) -> ProgramBytecode {
        let mut instructions = Vec::new();
        let mut functions = HashMap::new();

        for (name, function) in &self.functions {
            functions.insert(name.clone(), instructions.len() as u32);
            instructions.extend(function.instructions.iter().map(|instruction| {
                let instruction = instruction.clone();
                if let Instruction::Call(_call, _args) = &instruction {}
                instruction
            }));
        }

        ProgramBytecode {
            public_functions: functions,
            instructions,
        }
    }
}
